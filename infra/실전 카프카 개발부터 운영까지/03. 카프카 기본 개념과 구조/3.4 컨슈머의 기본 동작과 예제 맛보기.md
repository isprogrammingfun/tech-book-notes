## 3.4 컨슈머의 기본 동작과 예제 맛보기

### 3.4.1 컨슈머의 기본 동작
- 프로듀서가 카프카의 토픽으로 메세지를 전송하면 해당 메시지들은 브로커들의 로컬 디스크에 저장되고, 컨슈머는 토픽에 저장된 메시지를 가져올 수 있다.
- 컨슈머 그룹은 하나 이상의 컨슈머들이 모여 있는 그룹을 의미하고, 컨슈머는 반드시 컨슈머 그룹에 속하게 된다.
    - 컨슈머 그룹은 각 파티션의 리더에게 카프카 토픽에 저장된 메시지를 가져오기 위한 요청을 보낸다.
        - 이떄 파티션 수와 컨슈머 수는 일대일로 매핑되는 것이 이상적이다. 또한 파티션 수보다 컨슈머 수가 많게 구현되는 것은 바람직한 구성이 아니다. 컨슈머 수가 더 많으면 처리량이 높아지는 것이 아니라 단순 대기 상태로만 존재하게 되기 떄문이다.

### 3.4.2 컨슈머의 주요 옵션
| 컨슈머 옵션 | 설명 |
| --- | --- |
| `bootstrap.servers` | 프로듀서와 동일하게 브로커의 정보 입력 |
| `fetch.min.bytes` | 한 번에 가져올 수 있는 최소 데이터 크기. 지정한 크기보다 작은 경우, 데이터가 누적될 때까지 기다린다.  |
| `group.id` | 컨슈머가 속한 컨슈머 그룹을 식별하는 식별자. 동일한 그룹 내의 컨슈머 정보는 모두 공유된다. |
| `heartbeat.interval.ms` | 그룹 코디네이터에게 하트비트를 보내는 주기. 일반적으로 `session.timeout.ms` 의1/3로 설정해야 한다.  |
| `max.partition.fetch.bytes` | 파티션당 가져올 수 있는 최대 크기 |
| `session.timeout.ms`  | 컨슈머가 종료된 것인지를 판단. 이 시간 전까지 하트비트를 보내지 않으면 해당 컨슈머가 종료된 것으로 판단하여 리밸런싱 진행  |
| `enable.auto.commit` | 백그라운드로 주기적으로 오프셋을 커밋  |
| `auto.offset.reset`  | 카프카에서 초기 오프셋이 없거나 현재 오프셋이 더 이상 존재하지 않는 경우에 다음 옵션으로 reset </br> - earliest: 가장 초기의 오프셋 <br> - latest: 가장 마지막 오프셋 <br>- none: 이전 오프셋값을 찾지 못하면 에러 발생 |
| `fetch.max.bytes` | 한번의 가져오기 요청으로 가져올 수 있는 최대 크기 |
| `group.instanc.id` | 컨슈머의 고유한 식별자로 이를 설정할 경우 정적 멤버로 간주되어 불필요한 리밸런싱을 하지 않는다.  |
| `isolation.level` | 트랜잭션 컨슈머에서 사용되는 옵션으로 read_uncommitted는 기본적으로 모든 메시지를 읽고, read_committed는 트랜잭션이 완료된 메시지만 읽는다 |
| `max.poll.records` | 한번의 poll() 요청으로 가져오는 최대 메세지 수 |
| `partition.assignment.strategy` | 파티션 할당 전략이며, 기본값은 range |
| `fetch.max.wait.ms` | `fetch.min.bytes` 에 의해 설정된 데이터보다 적은 경우 요청에 대한 응답을 기다리는 최대 시간 |

