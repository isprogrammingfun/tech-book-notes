## 카프카의 핵심 개념
### 3.2.1 분산 시스템
- 분산 시스템은 장애 대응이 탁월하며 부하가 높은 경우에는 시스템 확장이 용이하다는 장점이 있다. 
    - 카프카 또한 분산 시스템이브로 리소스가 한계치에 도달해 더욱 높은 메시지 처리량이 필요한 경우, 브로커를 추가하는 방식으로 확장이 가능하다.

### 3.2.2 페이지 캐시
- 페이지 캐시는 직접 디스크에 읽고 쓰는 대신 물리 메모리 중 애플리케이션이 사용하지 않는 일부 잔여 메모리를 활용하므로 디스트 I/O에 대한 접근이 줄어들어 성능을 높일 수 있다.
    - 카프카는 이 페이지 캐시를 통해 읽고 쓰기를 하므로 높은 처리량을 핸들링 할 수 있다/

### 3.2.3 배치 전송 처리
- 카프카는 프로듀서, 컨슈머 클라이언트들과 통신하며 이들 사이에서 수많은 메세지를 주고받는다.
    - 이때 발생하는 수 많은 통신을 묶어 처리를 하게 된다면, 단건으로 통신할 떄에 비해 네트워크 오버헤드를 줄일 수 있으므로 카프카는 배치 전송을 권장한다.

### 3.2.4 압축 전송
- 카프카는 메시지 전송 시 좀 더 성능이 높은 압축 전송을 사용하는 것을 권장한다. (`gzip, snappy, lz4, zstd`등을 지원)
    - 압축을 권장하는 이유는 이를 통해 네트워크 대역 폭이나 회선 비용을 줄일 수 있으며, 배치 전송과 결합한다면 더욱 높은 효과를 얻게 되기 때문이다.
- 일반적으로 높은 압축률이 필요한 경우에는 `gzip, zstd`를, 빠른 응답 속도가 필요한 경우라면 `lz4, snappy`를 사용하는 것이 좋다.

### 3.2.5 토픽, 파티션, 오프셋
- 카프카는 토픽에 데이터를 저장한다. (메일 전송 시스템에서 이메일 주소 정도의 개념)
- 토픽은 병렬 처리를 위해 여러 개의 파티션으로 다시 나뉘어 높은 처리량을 수행할 수 있다.
- 이 파티션의 메세지가 저장되는 위치를 오프셋이라 부르며, 이 오프셋은 순차적으로 증가하는 숫자로 되어있다.
    - 각 파티션에서의 오프셋은 고유한 숫자로, 카프카에서는 오프셋을 통해 메시지의 순서를 보장하고 컨슈머에서는 마지막까지 읽은 위치를 알 수도 있다.

### 3.2.6 고가용성 보장
- 카프카는 고가용성을 보장하기 위해 리플리케이션 기능을 제공한다.
- 토픽을 생성할 때 옵션으로 리플리케이션 팩터 수를 지정할 수 있으며, 이 숫자에 따라 리플리케이션들이 존재한다. 이때, 토픽 자체를 복제하는 것이 아니라 토픽의 파티션을 복제한다는 점을 기억해야 한다.
- 원본과 리플리케이션을 구분하기 위해 리더와 팔로워라는 용어를 사용한다.
    - 리더는 프로듀서, 컨슈머로부터 오는 모든 읽기와 쓰기 요청을 처리하고, 팔로워는 오직 리더로부터 리플리케이션 하게 된다. 
- 팔로워 수가 많을수록 좋은 것은 아니다, 팔로워 수 만큼 결국 브로커의 디스크 공간이 소비되므로 이상적인 리플리케이션 팩터 수를 유지해야 한다. (기본적으로 3으로 구성하도록 권장)

### 3.2.7 주키퍼의 의존성
- 주키퍼는 여러 서버를 클러스터로 구성하고 살아 있는 노드가 과반수 이상 유지되며 지속적인 서비스가 가능한 구조다.
    - 따라서 주키퍼는 항상 홀수로 구성해야 한다.
- 지노드(znode)를 이용해 카프카 메타 정보가 주키퍼에 기록되며, 이 정보를 통해 브로커를 관리한다.
- 최근 카프카의 성장으로 주키퍼 성능 한계가 드러나 카프카는 주키퍼 의존성을 점점 제거하고 있는 추세다.