## 4.1 카프카 리플리케이션

### 4.1.1 리플리케이션 동작 개요

- 아래와 같이 토픽을 생성하면 토픽을 구성하는 각각의 파티션을 복제할 수 있다.

```java
kafka-topics.sh --bootstrap-server [브로커주소] --create --topic [토픽명] 
--partitions 1 --replication-factor 3
```

- 토픽으로 메세지 전송 시, 모든 브로커가 동일한 메세지를 갖게 된다.
    - 따라서 N개의 리플리케이션이 있는 경우 N - 1까지의 브로커 장애가 발생해도 메시지 손실 없이 안정적으로 메시지를 주고 받을 수 있다.

### 4.1.2 리더와 팔로워

- 카프카는 내부적으로 모두 동일한 리플리케이션들을 리더와 팔로워로 구분하고, 각자의 역할을 분담시킨다.
- 리더는 리플리케이션 중 하나가 선정되며, 모든 읽기와 쓰기는 해당 리더를 통해서만 가능하다.
    - 즉, 프로듀서는 리더에게만 메세지를 전송하고, 컨슈머도 오직 리더로부터 메시지를 가져온다.
- 팔로워는 리더에 문제가 발생하거나 이슈가 있을 경우를 대비해 언제든지 새로운 리더가 될 수 있도록 지속적으로 파티션의 리더가 새로운 메세지를 받았는지 확인하고, 있다면 리더로부터 복제한다.

### 4.1.3 복제 유지와 커밋

- 리더와 팔로워는 기본적으로 ISR(In Sync Replica)이라는 논리적 그룹으로 묶여있고, 이 ISR 그룹에 속하지 못하는 팔로워는 새로운 리더의 자격을 가질 수 없다.
- ISR 내의 팔로워들은 리더와의 데이터 일치를 유지하기 위해 지속적으로 리더의 데이터를 따라가게 되고, 리더는 ISR내 모든 팔로워가 메세지를 받을 때까지 기다린다.
    - 이때 네트워크 오류, 브로커 장애등으로 인해 뒤쳐저 리더와의 데이터가 불일치한 상태에 놓이게 되면, 이 팔로워에게 리더를 넘겨주게 될 경우 데이터 정합성, 메세지 손실등의 문제가 발생할 수 있으므로 리더는 팔로워들을 계속 감시한다. 이 감시 과정에서 특정 주기의 시간만큼 복제 요청을 하지 않는 팔로워들은 ISR 그룹에서 방출된다.
- ISR 내에서 모든 팔로워의 복제가 완료되었다면 리더는 내부적으로 커밋됐다는 표시를 하게 된다.
    - 커밋되었다는 것은 모든 리플리케이션이 메시지를 저장했음을 의미하고, 마지막 커밋 오프셋 위치 **(읽기 가능한 데이터의 경계선)**를 하이워터마크라 부른다.
- 컨슈머는 커밋된 메시지만 읽어갈 수 있다.
- 커밋되지 않은 메시지 읽기를 허용한다면 동일 토픽의 파티션에서 컨슘했음에도 메시지가 일치하지 않을 수 있다.
- 브로커는 커밋된 메시지를 유지하기 위해 로컬 디스크의 `replication-offset-checkpoint`라는 파일에 마지막 커밋 오프셋 위치를 저장한다.

### 4.1.4 리더와 팔로워의 단계별 리플리케이션 동작

- 리더가 리플리케이션 동작을 위해 팔로워들과 많은 통신을 주고받거나 리플리케이션 동작에 많은 관여를 하게된다면 리더의 성능이 떨어져 카프카의 장점인 빠른 성능을 내기 어려울 것이다.
- 따라서 카프카는 리더의 부하를 줄일 수 있게 리더와 팔로워 간의 통신을 최소화 할 수 있도록 설계되었고, 그 설계 중 하나는 다른 메시징 시스템들과는 다르게 ACK 통신 단계를 제거 했다는 것이다.

<aside>

    💡어떻게 ACK 통신 없이 안정적으로 리플리케이션이 가능할까?

    1. 팔로워들이 n번 오프셋에 대한 메시지를을 요청하면 리더는 (n - 1)번 메시지는 리플리케이션 되었다 인지하고 해당 위치에 커밋 표시를 한다.
    2. 팔로워가 n번 오프셋 메시지를 받지 못했다면 n번을 다시 요청할 것이기에 리더는 이를 통해 리플리케이션 성공 여부를 알 수 있게 된다.
    3. 팔로워로부터 n번 오프셋 메시지에 대한 리플리케이션 요청을 받은 리더는 (n - 1)번 오프셋 메시지가 커밋되었다는 응답을 팔로워에게 전달한다.
    4. 응답을 받은 팔로워는 리더와 동일하게 커밋을 표시한다.
</aside>

- 리더와 팔로워들의 리플리케이션 동작 방식 또한 부하를 줄이기 위해 리더가 push 하는 방식이 아닌 팔로워들이 pull하는 방식으로 동작한다.

### 4.1.5 리더에포크와 복구

- 카프카의 파티션들이 복구 동작을 할 때 메시지의 일관성을 유지하기 위한 용도로 이용된다.
- 컨트롤러에 의해 관리되는 32비트의 숫자로 표현

**[리더에포크가 없는 경우 메세지 손실 시나리오 - 파티션 수: 1, 리플리케이션 팩터: 2, min.insync.replicas: 1]**

1. 리더는 메시지 1(오프셋 0), 메시지 2(오프셋1) 을 받아 오프셋 1까지 커밋한 상황 (하이워터마크 = 2)
2. 팔로워는 메시지1(오프셋 0), 메시지2(오프셋1)을 받아, 오프셋 0까지 커밋한 상황, 아직 리더로부터 하이워터마크를 2로 올리는 내용을 전달 받지 못한 상태 (하이워터마크 = 1)
3. 예상 못한 장애로 팔로워 다운
4. 장애에서 복구된 팔로워는 내부적으로 메시지 복구 동작 진행
    1. 팔로워는 자신이 갖고 있는 메시지들 중 자신의 워터마크보다 높은 메시지들은 신뢰할 수 없는 메시지로 판단하고 삭제한다. → 메시지 2(오프셋1) 삭제
    2. 팔로워는 리더에게 1번 오프셋(메시지2)의 새로운 메시지 가져오기 요청을 보낸다.
    3. 이때 리더였던 브로커도 예상하지 못한 장애로 인해 다운된다면 파티션에 유일하게 남아있는 팔로워가 새로운 리더로 승격되면서 커밋된 메시지를 유실하게 된다(메시지2)

**[리더에포크를 사용해 복구하는 경우]**

1. 팔로워가 복구될 때 워터마크 이후 메세지를 무조건 삭제하는 것이 아니라 리더에게 리더에포크 요청을 보낸다. 
2. 리더는 “1번 오프셋의 message2 까지”라고 팔로워에게 보낸다.
3. 팔로워는 리더의 응답을 확인한 후 메시지2까지 하이워터마크를 상향조정한다.
4. 이 과정을 통해 메시지 손실이 발생하지 않아 리더가 장애로 다운되어 팔로워가 리더가 되어도 메시지 유실 이슈가 생기지 않는다.