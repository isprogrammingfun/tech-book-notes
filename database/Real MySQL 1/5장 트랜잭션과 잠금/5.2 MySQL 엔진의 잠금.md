## 5.2 MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.

<aside>

    ⚙ [스토리지 엔진 레벨]
    - 물리적으로 데이터를 저장.조회.수정하는 역할을 담당하는 엔진 계층
    - 디스크에 실제로 데이터를 저장하거나 불러오는 하위 계층
    - 테이블의 데이터와 인덱스를 읽고 저장, 데이터 락 관리

       [MySQL  엔진 레벨]
    - 쿼리 파싱, 최적화, 캐싱 관리 등 MySQL 서버 상위 계층에서 동작
    - 클라이언트로부터 쿼리 요청을 받고, 파싱, 플랜 작성, 실행 등을 담당하는 영역
    - 스토리지 엔진에 영향을 미치는 잠금(글로벌 락, 테이블 락, 메타데이터 락, 네임드 락 등) 관리
    - 스토리지 엔진 구분 없이 데이터베이스나 테이블 전체에 잠금을 걸 수 있음

</aside>

### 5.2.1 글로벌 락
- `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL에서 제공하는 잠금 가운데 가장 범위가 크다. 
- 한 세션에서 글로벌 락을 획득하게 되면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML문장은 글로벌 락이 해제될 때까지 대기 상태로 남는다.
- 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
- MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때는 글로벌 락을 사용해야 한다.
<aside>

    💡 글로벌 락은 실행과 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 건다. 글로벌 락 명형이 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행됐다면 이 명령은 먼저 실행된 SQL과 그 트랜잭션이 완료될 떄 까지 대기한다. 글로벌 락 명령은 테이블에 읽기 잠금을 걸기 전에 먼제 테이블을 FLUSH 해야 하기 때문에 테이블에 실행 중인 모든 종류의 쿼리가 완료되야 한다.

    글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 가급적 사용하지 않는 것이 좋다.

</aside>

- 글로벌 락은 MySQL 서버의 모든 변경 작업을 멈춘다. 하지만 트랜잭션을 지원하는 InnoDB 스토리지 엔진을 8.0 버전부터는 기본 엔진으로 채택하고 있는 상황에서 좀 더 가벼운 글로벌 락의 필요성이 생겼다.
- 따라서 8.0 버전부터 백업 락 `LOCK INSTANCE FOR BACKUP` 이 도입됐다.
- 백업 락을 획득했을 때 일반적인 테이블의 데이터 변경은 허용되나, 아래와 같은 정보는 변경이 불가능하다.
    - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
    - REPAIR TABLE과 OPTIMIZE TABLE 명령
    - 사용자 관리 및 비밀번호 변경
<aside>

    💡 XtraBackup과 Enterprise Backup 툴이 일관된 백업을 만드는 원리
    1. 트랜잭션 로그 시퀀스 번호 (LSN, Log Sequence Number)를 기록
        - LSN은 InnoDB 레벨에서 데이터 변경을 순차적으로 식별하기 위한 번호
        - 백업을 시작할 때 해당 시점의 LSN 값을 기록하고, 이 시점 이후의 데이터 변경 내역(redo log 포함)을 계속 추적
    2. 데이터 파일 + 변경 로그(redo log) 동시 확보
        - 데이터 파일 전체를 복사하는 동시에 새로 생기는 데이터 변경은 별도의 로그로 수집(redo log)
        - 모든 데이터 파일 복사가 끝난 후, 최종적으로 남아있는 redo log의 변경 내역도 한 번 더 수집해 백업에 포함
    3. 복원 시
        - 데이터 파일을 먼저 복원하고, 저장된 redo log를 LSN이 백업이 끝난 시점까지 적용

</aside>

### 5.2.2 테이블 락
- 테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. (`LOCK TABLES table_name [READ | WRITE]`)
    - 명시적 테이블 락 또한 글로벌 락과 동일하게 작업에 영향을 미치기 때문에 특별한 상황이 아니라면 쓰지 않는 것이 좋다.
- 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. (변경되는 테이블에 잠금 설정 -> 데이터 변경 후 즉시 잠금 해제)
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하므로 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다.
    - 정확히는 InnoDB 또한 테이블 락이 설정되긴 하지만, DDL의 경우에만 발생한다.

### 5.2.3 네임드 락
- `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 즉, 대상이 테이블이나 레코드 또는 데이터베이스 객체가 아니다.
- 네임드 락은 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이고, 자주 사용되지는 않는다.
- 네임드 락의 경우 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
    - EX) 배치 프로그램에서 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리 실행

### 5.2.4 메타데이터 락
- 메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다. 
- 명시적으로 획득하거나 해제할 수 있는 것이 아니고, `RENAME TABLE a TO b` 와 같이 명령을 통해 변경하는 경우에 자동으로 잠금을 획득한다. 
    - `RENAME TABLE` 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.
- 이름 변경 작업을 둘로 나눠서 실행하면 아주 짧은 순간에 변경할 테이블 이름이 존재하지 않아 오류가 발생할 수 있다.
```sql
-- 한 번에 실행하는 건 문제 없음
RENAME TABLE rank TO rank_backup, rank_new TO rank;

-- 두 개로 나눠서 실행하면 table not found rank 오류 발생 가능
RENAME TABLE rank TO rank_backup;
RENAME TABLE rank_new TO rank;

```
- 테이블의 구조를 변경해야 하는 상황에서 발생할 수 있는 이슈
    - 테이블 사이즈가 크면 MySQL 서버는 DDL 을 단일 스레드로 처리하기 때문에 시간이 오래 걸린다
    - 새로운 구조의 테이블을 생성한 뒤, `... WHERE id >= 0 AND id < 10000;`, `... WHERE id >= 10000 AND id < 20000;` 와 같이 최근 데이터(1시간 직전 또는 하루 전)까지는 pk 값을 범위 별로 나눠서 여러 스레드로 빠르게 복사한다.
    - 나머지 값들은 테이블 락을 명시적으로 획득한 후 마저 복사한다.(잠금 시간 최소화를 위해 가능하면 미리 아주 최근 데이터까지 복사해두는 것이 좋음)
    - 테이블 이름을 변경한 후, 사용하지 않게 된 테이블을 DROP 문으로 제거한다.


